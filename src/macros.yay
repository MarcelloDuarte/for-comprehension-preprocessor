<?php

macro ·recursion {
    for {
        ·ls (
            ·chain(
                ·either(
                    ·token(T_VARIABLE),
                    ·either(
                        ·label('_'),
                        ·chain(
                            ·token('('),
                            ·optional(·ls(·either(·token(T_VARIABLE), ·token('_')), ·token(','))),
                            ·token(')')
                        )
                    )
                )·binded,
                ·operator('<-'),
                ·layer()·bind
            ),
            ·token(T_WHITESPACE, "\n")
        )·binds
        ·_()·for
    } yield ·either(
                ·token(T_VARIABLE),
                ·chain(
                    ·token('('),
                    ·optional(·ls(·token(T_VARIABLE), ·token(','))),
                    ·token(')')
                )
            )·fields

} >> function($ast) {
    $binds = [];

    if (is_array($ast->{'·binds'}[0]['·binded'])) {
        $binds[0]['binded'] = [];
        for ($i = 0; $i < count($ast->{'·binds'}[0]['·binded'][1]); $i++) {
            $binds[0]['binded'][] = (string)$ast->{'·binds'}[0]['·binded'][1][$i];
        }
    } else {
        $binds[0]['binded'] = (string)$ast->{'·binds'}[0]['·binded'] == '_' ?
            '$_' :
            (string)$ast->{'·binds'}[0]['·binded'];
    }

    list ($binds[0]['bind'], $remaining) = (function($bind) {
        $binded = '';
        foreach ($bind as $i => $token) {
            if ($token->is(T_WHITESPACE) && stristr((string)$token, "\n")) {
                return [$binded, array_slice($bind, $i+1)];
            }
            $binded .= (string) $token;
        }
    })($ast->{'·binds'}[0]['·bind']);

    $channel = 'newline';
    $i = count($binds) - 1;

    foreach ($remaining as $token) {
        if ($channel == 'newline' && ($token->is(T_VARIABLE) || (string)$token === '_')) {
            $channel = 'looking for operator';
            $binds[$i + 1]['binded'] = ((string) $token == '_') ? '$_' : (string) $token;
            continue;
        }

        if ($channel == 'newline' && $token->is('(')) {
            $channel = 'looking for binded tuples';
        }

        if ($channel == 'looking for binded tuples' && ($token->is(T_VARIABLE) || (string)$token === '_')) {
            if (!isset($binds[$i + 1]['binded'])) {
                $binds[$i + 1]['binded'] = [];
            }
            $binds[$i + 1]['binded'][] = ((string) $token == '_') ? '$_' : (string) $token;
        }

        if ($channel == 'looking for binded tuples' && $token->is(')')) {
            $channel = 'looking for operator';
        }

        if ($channel == 'looking for operator' && $token->is("<")) {
            $channel = 'inside bind operator';
            continue;
        }

        if ($channel == 'inside bind operator' && $token->is("-")) {
            $channel = 'looking for binds';
            continue;
        }

        if ($channel == 'looking for binds' && !($token->is(T_WHITESPACE) && stristr((string)$token, "\n"))) {
            if (!isset($binds[$i + 1]['bind'])) {
                $binds[$i + 1]['bind'] = '';
            }
            $binds[$i + 1]['bind'] .= (string) $token;
        } elseif ($channel == 'looking for binds') {
            $i++;
            $channel = 'newline';
        }
        if (isset($binds[$i + 1]['bind'])) {
            $binds[$i + 1]['bind'] = ltrim($binds[$i + 1]['bind']);
        }
    }

    $fields = '';
    if (is_array($ast->{'·fields'})) {

        switch (count($ast->{'·fields'}[1])) {
            case 0: $fields = "Unit()"; break;
            case 1: $fields = "Tuple({$ast->{'·fields'}[1][0]})"; break;
            case 2: $fields = "Pair({$ast->{'·fields'}[1][0]}, {$ast->{'·fields'}[1][1]})"; break;
            default:
                $fields = "Tuple(" .
                    implode(', ', array_map(function($field){ return (string) $field; }, $ast->{'·fields'}[1])) .
                ")"; break;
        }
    } else {
        $fields = (string)$ast->{'·fields'};
    }

    $useVariables = [];

    $indent = function($currentCount) use ($binds) {
        $numberOfFlatMaps = count($binds);
        return str_repeat(" ", ($numberOfFlatMaps - $currentCount) * 4);
    };

    $comprenhension = function($binds) use ($fields, &$comprenhension, &$useVariables, $indent) {
        $use = count($useVariables) ? ' use (' . implode(', ', $useVariables) . ') ' : '';

        if (count($binds) == 1) {

            $body = '';
            if (is_array($binds[0]['binded'])) {
                for ($i = 0; $i < count($binds[0]['binded']); $i++) {
                    $body .= $indent(0) . "{$binds[0]['binded'][$i]} = \$t" . count($binds) . "->_" . ($i + 1) . ";\n";
                    $var = '$t' . count($binds);
                }
            } else {
                $var = (string)$binds[0]['binded'];
            }

            return "{$binds[0]['bind']}->map(function({$var})$use{\n" .
                $body .
                $indent(0) . "return $fields;\n" .
                $indent(1) . "})";

        } else {

            $body = '';
            if (is_array($binds[0]['binded'])) {
                for ($i = 0; $i < count($binds[0]['binded']); $i++) {
                    $body .= $indent(count($binds) - 1) . "{$binds[0]['binded'][$i]} = \$t" . count($binds) . "->_" . ($i + 1) . ";\n";
                    $var = '$t' . count($binds);
                    $useVariables[] = (string) $binds[0]['binded'][$i];
                }
            } else {
                $var = (string)$binds[0]['binded'];
                $useVariables[] = (string) $binds[0]['binded'];
            }


            $flatMap = "{$binds[0]['bind']}->flatMap(function({$var})$use {\n" .
            $body .
            $indent(count($binds) - 1) . "return " . $comprenhension(array_slice($binds, 1)) . ";\n" .
            $indent(count($binds)) . "})";
            return $flatMap;
        }
    };

    $for = new \Yay\Ast('·for');
    $for->push(new \Yay\Ast('·comprenhension', new Yay\Token(T_STRING, $comprenhension($binds))));

    $ast->append($for);
} >> {
    ·for?·{·for ···{ ·comprenhension}}
}
